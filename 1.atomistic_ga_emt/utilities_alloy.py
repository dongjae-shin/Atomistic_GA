import os
import numpy as np
from random import shuffle
from random import choice, random
from ase import Atoms
from ase.ga.offspring_creator import OffspringCreator
#from ase.calculators.emt import EMT
from ase.optimize import BFGS

def get_atom_types(alloy):
    """ Utility method used to extract all unique atom types
        from the atoms object. """
    from_alloy = list(set(alloy.numbers))
    return list(set(from_alloy))

class StartGenerator(object):
    """ Class used to generate random starting candidates.
        The candidates are generated by shuffling the coordinates of all the
        atoms

        Parameters:
    """
    def __init__(self, alloy, atom_numbers):#,
                # closest_allowed_distances, box_to_place_in=None):
        self.alloy = alloy
        self.atom_numbers = atom_numbers
        #self.blmin = closest_allowed_distances
        #if box_to_place_in is None:
        #    p0 = np.array([0., 0., 0.])
        #    cell = self.alloy.get_cell()
        #    self.box = [p0, [cell[0, :], cell[1, :], cell[2, :]]]
        #else:
        #    self.box = box_to_place_in

    def get_new_candidate(self):
        """ Returns a new candidate. """
        N = len(self.atom_numbers)
        cell = self.alloy.get_cell()
        pbc = self.alloy.get_pbc()
    
        # The ordering is shuffled first
        # ultimately it shuffles the coordinates of all the atoms.
        order = list(range(N))
        shuffle(order)

        pos = self.alloy.positions
        new_pos = np.zeros((N,3))
        for i in range(N):
            new_pos[order[i]] = pos[i]
        #shuffle(new_pos) ;array of array cannot be shuffled directly
        #no error, but weird result

        candidate = Atoms(numbers=self.atom_numbers, positions=new_pos, 
                          pbc=pbc, cell=cell)
        candidate.info['ordering'] = order # ordering information

        return candidate

class SurvivorSelector(object):
    """ Class used to select survivors in the populatoin pool.
        (to be written...)
    """ 
    def __init__(self, population, calculator, queue=False):
        self.population = population
        self.calculator = calculator
        self.queue = queue

    def get_parents(self, num_parents):
        parents = []
        fitness = self._get_fitness()
        for i in range(num_parents):
            imax = np.where(np.array(fitness) == max(fitness))[0][0]
            parents = parents + [self.population[imax]]
            fitness[imax] = -1.
            print "a parent from index {0}.".format(imax)

        return parents

    def _get_fitness(self):
        """ This method calculates fitness function following the idea
        presented in J. Comp. Chem. 26, 10 (2005).
        """

        energies = self._get_energies()
        # energies = [a.get_potential_energy(queue=True) for a in
        #        self.population]

        rho = [(energy-min(energies)) / (max(energies)-min(energies)) for
                energy in energies]
        # N.B. np.array operation is different from list operation
        fitness = [0.5 * (1. - np.tanh(2.*i - 1.)) for i in rho]

        return fitness

    def _get_energies(self): 
        energies = []
        for a in self.population:
            # prevent calculating twice
            if 'tot_energy' in a.info:
                print "this candidate already have total energy."
                energies += [a.info['tot_energy']]
            else:
                print "this candidate doesn't have total energy."
                a.set_calculator(self.calculator)
                if self.queue:
                    a.info['tot_energy'] = a.get_potential_energy(queue=True)
                else:
                    a.info['tot_energy'] = a.get_potential_energy()
                energies += [a.info['tot_energy']]
        return energies

    def where_are_lowest(self, num_offspring):
        """ This method gives the indices of the lowest candidates to be
            extinct.
        """
        i_where = []
        fitness = self._get_fitness()
        for i in range(num_offspring):
            imin = np.where(np.array(fitness) == min(fitness))[0][0]
            i_where = i_where + [imin]
            print "lowest one from index {0}.".format(imin)
            fitness[imin] = 1.5

        return i_where

class CoordinatePairing(OffspringCreator):
    """ The operator that pairs two c oordinate arrays of two individual atoms
        object, which means the phenotype is coordinate of the atoms included.
    """
    def __init__(self, alloy, verbose= False):
        OffspringCreator.__init__(self, verbose)
        #self.blmin = blmin
        self.alloy = alloy
        self.descriptor = 'CoordinatePairing'
        self.min_inputs = 1

    def get_new_individual(self, parents):
        """ The method called by the user 
        that returns the paired structure.
        """
        f, m = parents

        indi = self.cross(f, m)
        desc = 'pairing: {0} {1}'.format(f.info['confid'],
                                         m.info['confid'])
        # It is ok for an operator to return None
        # It means that it could not make a legal offspring
        # within a reasonable amount of time
        if indi is None:
            return indi, desc
        indi = self.initialize_individual(f, indi)
        indi.info['data']['parents'] = [f.info['confid'],
                                        m.info['confid']]
        
        return self.finalize_individual(indi), desc

    def cross(self, a1, a2): 
        """ Crosses the two atoms objects and returns one;
        Order 1 Crossover
        """

        if len(a1) != len(self.alloy):
            raise ValueError('Wrong size of structure to optimize')
        if len(a1) != len(a2):
            raise ValueError('The two structures do not have the same length')

        N = len(self.alloy.numbers)
        cell = self.alloy.get_cell()
        pbc = self.alloy.get_pbc()
        atom_numbers = self.alloy.numbers
        pos = self.alloy.positions
        new_pos = np.zeros((N,3))

        # Doing order 1 crossover using ordering list
        order1 = list(a1.info['ordering'])
        order2 = list(a2.info['ordering'])
        # built-in list() function was used to avoid call-by-reference of 
        # a2.info['ordering']
        new_order = list(np.zeros(N))

        rpi = -choice(range(N)) # initial point of random swath
        rpf = rpi + N/2         # final point of random swath

        # Possibilities of making swath from pos1
        if   rpi < 0 and rpf < 0:
             # case 1
             new_order[rpi:rpf] = order1[rpi:rpf]
        elif rpi < 0 and rpf ==0:
             # case 2
             new_order[rpi:] = order1[rpi:]
        elif rpi < 0 and rpf > 0:
             # case 3
             new_order[rpi:] = order1[rpi:]
             new_order[:rpf] = order1[:rpf]
        elif rpi == 0 and rpf > 0:
             # case 4
             new_order[:rpf] = order1[:rpf]
        else:
             print "else case ocurred!"

        # Masking coordinates already selected from a1
        # 'del' is not compatible with array format
        for i in range(rpi,rpf):
            imask = np.where(np.array(order2) == new_order[i])[0][0]
            del order2[imask]

        Np = len(order2)

        # Fill in the rest of new_order list by with the rest of order2
        if  rpi < 0 and rpf < 0:
            # case 1
            new_order[N+rpf:] = order2[Np+rpf:]
            new_order[:N+rpi] = order2[:Np+rpi]
        elif rpi < 0 and rpf ==0:
            # case 2
            new_order[:rpi] = order2
        elif rpi < 0 and rpf > 0:
            # case 3
            new_order[rpf:N+rpi] = order2
        elif rpi == 0 and rpf > 0:
            # case 4
            new_order[rpf:] = order2
        else:
            print "else case ocurred!"

        # Fill in new_pos array following the new_order list
        for i in range(N):
            new_pos[new_order[i]] = pos[i]

        alloy_offspring = Atoms(numbers=atom_numbers, positions=new_pos,
                                pbc=pbc, cell=cell)
        alloy_offspring. info['ordering'] = new_order

        return alloy_offspring

class CoordinateSwapMutation(OffspringCreator):
    """ A Coordinate swap mutation, (for 2-element sys.)
        This mutation randomly chooses two atoms each with different type 
        and swaps their coordinates.

        Parameters:
        all_atom_types: the list of atomic numbers withous overlapping

    """
    def __init__(self, all_atom_types, alloy, verbose=False):
        OffspringCreator.__init__(self, verbose)
        self.descriptor = 'CoordinateSwapMutation'
        self.min_inputs = 2
        self.atom_types = all_atom_types
        self.alloy = alloy

    def get_new_individual(self, parents):
        f = parents[0]

        indi = self.mutate(f)
        if indi is None:
            return indi, 'mutation: coordinateswap'
            
        indi = self.initialize_individual(f, indi)
        indi.info['data']['parents'] = [f.info['confid']]

        return self.finalize_individual(indi), 'mutation: coordinateswap'

    def mutate(self, atoms):
        """ Do the mutation of the atoms input.
            
            comment: how about applying probability to the number of swapping?
        """
        # Original alloy's coordinate
        pos = self.alloy.positions

        cell = atoms.get_cell()
        pbc = atoms.get_pbc()
        atom_numbers = atoms.numbers
        N = len(atom_numbers)
        order = atoms.info['ordering']
        new_pos = np.zeros((N,3))

        # swap randomly chosen two atoms with different atomic number
        i_e1 = np.where(atom_numbers == self.atom_types[0])[0]
        i_e2 = np.where(atom_numbers == self.atom_types[1])[0]
        pair1, pair2 = [np.random.choice(i_e1), np.random.choice(i_e2)]
        order[pair1], order[pair2] = order[pair2], order[pair1]

        # Fill in new_pos array following the new order list
        for i in range(N):
            new_pos[order[i]] = pos[i]

        alloy_offspring = Atoms(numbers=atom_numbers, positions=new_pos,
                                pbc=pbc, cell=cell)
        alloy_offspring.info['ordering'] = order 

        return alloy_offspring
